import type { AnyBlock } from '@slack/types'
import type { ContextBlock, HeaderBlock } from '@slack/types/dist/block-kit/blocks'
import type { TextObject } from '@slack/types/dist/block-kit/composition-objects'
import { IncomingWebhook } from '@slack/webhook'
import { FooterType } from '../types'
import type Representation from '../representations/Representation'
import { version } from '../metadata.json'

/**
 * Options for the SlackMessageBuilder.
 * @internal
 */
export type SlackMessageOptions = {
  username?: string
  iconUrl?: string
  color?: string
  representation: Representation,
}

/**
 * Interface for a Slack message that can be sent.
 * @internal
 */
export interface SlackMessage {
  /**
   * Sends the Slack message.
   * @returns A promise that resolves to the response from the Slack webhook.
   */
  send: () => Promise<string>
  withActor(actor?: string): void
  withFooter(text?: string, type?: FooterType): void
  withHeader(header?: string): void
  withRun(): void
}

/**
 * Creates a new instance of {@link SlackMessage} class.
 * @param url Slack webhook URL
 * @param opts An instance of {@link SlackMessageOptions} type.
 */
export function createSlackMessage(url: string, opts: SlackMessageOptions): SlackMessage {
  return new SlackMessageImpl(url, opts)
}

/**
 * Class for building and sending Slack messages based on SARIF logs.
 * @internal
 */
class SlackMessageImpl implements SlackMessage {
  private readonly _webhook: IncomingWebhook
  private readonly _gitHubServerUrl: string
  private readonly _color?: string
  private readonly _representation: Representation

  private _header?: HeaderBlock
  private _footer?: ContextBlock
  private _actor?: string
  private _runId?: string

  constructor(url: string, opts: SlackMessageOptions) {
    this._webhook = new IncomingWebhook(url, {
      username: opts.username || 'SARIF results',
      icon_url: opts.iconUrl
    })
    this._gitHubServerUrl = process.env.GITHUB_SERVER_URL || 'https://github.com'
    this._color = opts.color
    this._representation = opts.representation
  }

  withHeader(header?: string): void {
    this._header = {
      type: 'header',
      text: {
        type: 'plain_text',
        text: header || process.env.GITHUB_REPOSITORY || 'SARIF results'
      }
    }
  }

  withActor(actor?: string): void {
    this._actor = actor || process.env.GITHUB_ACTOR
  }

  withRun(): void {
    this._runId = process.env.GITHUB_RUN_ID
  }

  withFooter(text?: string, type?: FooterType): void {
    const repoName = 'fabasoad/sarif-to-slack'
    const element: TextObject = text
      ? { type: type || FooterType.PlainText, text }
      : { type: FooterType.Markdown, text: `Generated by <${this._gitHubServerUrl}/${repoName}|@${repoName}@${version}>` }
    this._footer = {
      type: 'context',
      elements: [element],
    }
  }

  async send(): Promise<string> {
    const blocks: AnyBlock[] = []
    if (this._header) {
      blocks.push(this._header)
    }
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: this.buildText(),
      }
    })
    if (this._footer) {
      blocks.push(this._footer)
    }
    const { text } = await this._webhook.send({
      attachments: [{ color: this._color, blocks }]
    })
    return text
  }

  private buildText(): string {
    const text: string[] = []
    if (this._actor) {
      const actorUrl = `${this._gitHubServerUrl}/${this._actor}`
      text.push(`_Triggered by <${actorUrl}|${this._actor}>_`)
    }
    text.push(this._representation.compose())
    if (this._runId) {
      let runText: string = 'Job '
      if (process.env.GITHUB_REPOSITORY) {
        runText += `<${this._gitHubServerUrl}/${process.env.GITHUB_REPOSITORY}/actions/runs/${this._runId}|#${this._runId}>`
      } else {
        runText += `#${this._runId}`
      }
      text.push(runText)
    }
    return text.join('\n\n')
  }
}
