import { AnyBlock } from '@slack/types'
import { ContextBlock, HeaderBlock } from '@slack/types/dist/block-kit/blocks'
import { TextObject } from '@slack/types/dist/block-kit/composition-objects'
import { IncomingWebhook } from '@slack/webhook'
import { Map as ImmutableMap } from 'immutable'
import {
  CalculateResultsBy,
  FooterType,
  GroupResultsBy,
  SarifLog,
  SarifToSlackOutput,
  SlackMessage
} from './types'
import { LIB_VERSION } from './metadata'
import {
  DataGroupedByRun,
  SarifModelPerSarif
} from './model/SarifModelPerSarif';
import { SecurityLevel, SecuritySeverity } from './model/types';

/**
 * Options for the SlackMessageBuilder.
 * @internal
 */
export type SlackMessageBuilderOptions = {
  username?: string
  iconUrl?: string
  color?: string
  sarif: SarifLog,
  output?: SarifToSlackOutput,
}

/**
 * Class for building and sending Slack messages based on SARIF logs.
 * @internal
 */
export class SlackMessageBuilder implements SlackMessage {
  private readonly webhook: IncomingWebhook
  private readonly gitHubServerUrl: string
  private readonly color?: string
  private readonly sarifModelPerSarif: SarifModelPerSarif
  private readonly output: SarifToSlackOutput
  private header?: HeaderBlock

  private footer?: ContextBlock
  private actor?: string
  private runId?: string

  public readonly sarif: SarifLog

  constructor(url: string, opts: SlackMessageBuilderOptions) {
    this.webhook = new IncomingWebhook(url, {
      username: opts.username || 'SARIF results',
      icon_url: opts.iconUrl
    })
    this.gitHubServerUrl = process.env.GITHUB_SERVER_URL || 'https://github.com'
    this.color = opts.color
    this.sarif = opts.sarif
    this.sarifModelPerSarif = new SarifModelPerSarif(opts.sarif)
    this.output = opts.output || {
      groupBy: GroupResultsBy.ToolName,
      calculateBy: CalculateResultsBy.Level
    }
  }

  withHeader(header?: string): void {
    this.header = {
      type: 'header',
      text: {
        type: 'plain_text',
        text: header || process.env.GITHUB_REPOSITORY || 'SARIF results'
      }
    }
  }

  withActor(actor?: string): void {
    this.actor = actor || process.env.GITHUB_ACTOR
  }

  withRun(): void {
    this.runId = process.env.GITHUB_RUN_ID
  }

  withFooter(text?: string, type?: FooterType): void {
    const repoName = 'fabasoad/sarif-to-slack'
    const element: TextObject = text
      ? { type: type || FooterType.PlainText, text }
      : { type: FooterType.Markdown, text: `Generated by <${this.gitHubServerUrl}/${repoName}|@${repoName}@${LIB_VERSION}>` }
    this.footer = {
      type: 'context',
      elements: [element],
    }
  }

  async send(): Promise<string> {
    const blocks: AnyBlock[] = []
    if (this.header) {
      blocks.push(this.header)
    }
    blocks.push({
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: this.buildText()
      }
    })
    if (this.footer) {
      blocks.push(this.footer)
    }
    const { text } = await this.webhook.send({
      attachments: [{ color: this.color, blocks }]
    })
    return text
  }

  private buildText(): string {
    const text: string[] = []
    if (this.actor) {
      const actorUrl = `${this.gitHubServerUrl}/${this.actor}`
      text.push(`_Triggered by <${actorUrl}|${this.actor}>_`)
    }
    text.push(this.composeSummary())
    if (this.runId) {
      let runText: string = 'Job '
      if (process.env.GITHUB_REPOSITORY) {
        runText += `<${this.gitHubServerUrl}/${process.env.GITHUB_REPOSITORY}/actions/runs/${this.runId}|#${this.runId}>`
      } else {
        runText += `#${this.runId}`
      }
      text.push(runText)
    }
    return text.join('\n\n')
  }

  private composeSummaryWith(
    map: ImmutableMap<SecurityLevel | SecuritySeverity, number>,
    resultProcessor: (result: string) => string = (result: string): string => result,
  ): string {
    const stats = new Array<string>()
    for (const [key, count] of map.entries()) {
      stats.push(`*${key}*: ${count}`)
    }
    return resultProcessor(
      stats.length == 0 ? 'No issues found' : stats.join(', ')
    )
  }

  private composeSummary(): string {
    const summaries = new Array<string>()
    switch (this.output.groupBy) {
      case GroupResultsBy.ToolName: {
        const dataGroupedByToolName: Map<string, ImmutableMap<SecurityLevel | SecuritySeverity, number>> =
          this.output.calculateBy === CalculateResultsBy.Level
            ? this.sarifModelPerSarif.groupByToolNameWithSecurityLevel()
            : this.sarifModelPerSarif.groupByToolNameWithSecuritySeverity()
        for (const [toolName, map] of dataGroupedByToolName.entries()) {
          summaries.push(this.composeSummaryWith(
            map,
            (result: string): string => `*${toolName}*\n${result}`
          ))
        }
        break
      }
      case GroupResultsBy.Run: {
        const dataGroupedByRun: Array<DataGroupedByRun<SecurityLevel | SecuritySeverity>> =
          this.output.calculateBy === CalculateResultsBy.Level
            ? this.sarifModelPerSarif.groupByRunWithSecurityLevel()
            : this.sarifModelPerSarif.groupByRunWithSecuritySeverity()
        for (let i = 0; i < dataGroupedByRun.length; i++) {
          const { data, toolName } = dataGroupedByRun[i]
          summaries.push(this.composeSummaryWith(
            data,
            (result: string): string => `_[Run ${i + 1}]_: *${toolName}*\n${result}`
          ))
        }
        break
      }
      default: {
        const dataTotal: ImmutableMap<SecurityLevel | SecuritySeverity, number> =
          this.output.calculateBy === CalculateResultsBy.Level
            ? this.sarifModelPerSarif.groupByTotalWithSecurityLevel()
            : this.sarifModelPerSarif.groupByTotalWithSecuritySeverity()
        const toolNames: Set<string> = this.sarifModelPerSarif.listToolNames()
        summaries.push(this.composeSummaryWith(
          dataTotal,
          (result: string): string => `*${Array.from(toolNames).join('*, *')}*\n${result}`
        ))
        break
      }
    }
    return summaries.join('\n\n')
  }
}
